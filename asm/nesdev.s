;
; File generated by cc65 v 2.16 - Git N/A
;
	.fopt		compiler,"cc65 v 2.16 - Git N/A"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.import		_pal_bg
	.import		_oam_spr
	.import		_oam_meta_spr
	.import		_scroll
	.import		_rand8
	.import		_vram_adr
	.import		_vram_put
	.export		_flash
	.export		_shake
	.export		_spr
	.export		_metaspr
	.export		_move_rect
	.export		_point_in_rect
	.export		_rect_collides
	.export		_digit_update
	.export		_digit_increment
	.export		_nt_print

; ---------------------------------------------------------------
; void __near__ __fastcall__ flash (__near__ const unsigned char *, __near__ const unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_flash: near

.segment	"DATA"

L0003:
	.byte	$00

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; flashing ^= 1;
;
	lda     L0003
	eor     #$01
	sta     L0003
;
; pal_bg(flashing ? flash_palette : normal_palette);
;
	lda     L0003
	beq     L0009
	ldy     #$01
	jmp     L0076
L0009:	ldy     #$03
L0076:	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _pal_bg
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ __fastcall__ shake (signed char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_shake: near

.segment	"DATA"

L000E:
	.byte	$00
L0010:
	.byte	$00

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; scroll_x = rand8() % force;
;
	jsr     _rand8
	jsr     pushax
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	bpl     L0014
	dex
L0014:	jsr     tosumodax
	sta     L000E
;
; scroll_y = rand8() % force;
;
	jsr     _rand8
	jsr     pushax
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	bpl     L0017
	dex
L0017:	jsr     tosumodax
	sta     L0010
;
; if (rand8() > 128)
;
	jsr     _rand8
	cmp     #$81
	bcc     L0018
;
; scroll_x *= -1;
;
	lda     L000E
	jsr     pusha0
	ldx     #$FF
	txa
	jsr     tosumulax
	sta     L000E
;
; if (rand8() > 128)
;
L0018:	jsr     _rand8
	cmp     #$81
	bcc     L0077
;
; scroll_y *= -1;
;
	lda     L0010
	jsr     pusha0
	ldx     #$FF
	txa
	jsr     tosumulax
	sta     L0010
;
; scroll(scroll_x, scroll_y);
;
L0077:	lda     L000E
	jsr     pusha0
	lda     L0010
	jsr     _scroll
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ __fastcall__ spr (__near__ const struct sprite *, __near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_spr: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; *oam_ptr = oam_spr(sprite->x, 
;
	jsr     pushw0sp
	jsr     decsp4
	ldy     #$09
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$03
	lda     (ptr1),y
	sta     (sp),y
;
; sprite->y, 
;
	ldy     #$09
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	ldy     #$02
	sta     (sp),y
;
; sprite->tile_index, 
;
	ldy     #$09
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$01
	lda     (ptr1),y
	sta     (sp),y
;
; 0, 
;
	lda     #$00
	dey
	sta     (sp),y
;
; *oam_ptr);
;
	ldy     #$07
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	jsr     _oam_spr
	ldy     #$00
	jsr     staspidx
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ __fastcall__ metaspr (__near__ const struct metasprite *, __near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_metaspr: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; *oam_ptr = oam_meta_spr(metasprite->x, 
;
	jsr     pushw0sp
	jsr     decsp3
	ldy     #$08
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	ldy     #$02
	sta     (sp),y
;
; metasprite->y, 
;
	ldy     #$08
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$01
	lda     (ptr1),y
	sta     (sp),y
;
; *oam_ptr, 
;
	ldy     #$06
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	sta     (sp),y
;
; metasprite->index_buffer);
;
	ldy     #$08
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$03
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     _oam_meta_spr
	ldy     #$00
	jsr     staspidx
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ __fastcall__ move_rect (__near__ struct rect *, unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_move_rect: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; rect->x = x;
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	dey
	lda     (sp),y
	dey
	sta     (ptr1),y
;
; rect->y = y;
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (sp),y
	iny
	sta     (ptr1),y
;
; rect->max_x = rect->x + rect->w;
;
	ldy     #$05
	jsr     pushwysp
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldx     #$00
	lda     (ptr1,x)
	jsr     pusha0
	ldy     #$07
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$02
	lda     (ptr1),y
	jsr     tosadda0
	ldy     #$04
	jsr     staspidx
;
; rect->max_y = rect->y + rect->h;
;
	ldy     #$05
	jsr     pushwysp
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$01
	lda     (ptr1),y
	jsr     pusha0
	ldy     #$07
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$03
	lda     (ptr1),y
	jsr     tosadda0
	ldy     #$05
	jsr     staspidx
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ point_in_rect (__near__ const struct rect *, unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_point_in_rect: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; return (x > rect->x && y > rect->y && x < rect->max_x && y < rect->max_y);
;
	ldy     #$01
	lda     (sp),y
	jsr     pusha0
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1,x)
	jsr     tosicmp0
	bcc     L003E
	beq     L003E
	ldx     #$00
	lda     (sp,x)
	jsr     pusha0
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$01
	lda     (ptr1),y
	jsr     tosicmp0
	bcc     L003E
	beq     L003E
	ldy     #$01
	lda     (sp),y
	jsr     pusha0
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1),y
	jsr     tosicmp0
	bcs     L003E
	ldx     #$00
	lda     (sp,x)
	jsr     pusha0
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	iny
	lda     (ptr1),y
	jsr     tosicmp0
	bcc     L003D
L003E:	ldx     #$00
	txa
	jmp     incsp4
L003D:	lda     #$01
	ldx     #$00
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ rect_collides (__near__ const struct rect *, __near__ const struct rect *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_rect_collides: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; return (first->x < second->max_x && 
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldx     #$00
	lda     (ptr1,x)
	jsr     pusha0
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$04
	lda     (ptr1),y
	jsr     tosicmp0
	bcs     L0043
;
; first->max_x > second->x &&
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$04
	lda     (ptr1),y
	jsr     pusha0
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1,x)
	jsr     tosicmp0
	bcc     L0043
	beq     L0043
;
; first->y < second->max_y && 
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	dey
	lda     (ptr1),y
	jsr     pusha0
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$05
	lda     (ptr1),y
	jsr     tosicmp0
	bcs     L0043
;
; first->max_y > second->y);
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$05
	lda     (ptr1),y
	jsr     pusha0
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	dey
	lda     (ptr1),y
	jsr     tosicmp0
	beq     L0043
	bcs     L0042
L0043:	ldx     #$00
	txa
	jmp     incsp4
L0042:	lda     #$01
	ldx     #$00
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ __fastcall__ digit_update (__near__ struct digits *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_digit_update: near

.segment	"DATA"

L0046:
	.byte	$00

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; for (i = 0; i < 6; ++i)
;
	lda     #$00
	sta     L0046
L007D:	lda     L0046
	cmp     #$06
	bcs     L0049
;
; if (digits->segments[i] > 9)
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     L0046
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$0A
	bcc     L007E
;
; digits->segments[i]    = 0;
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     L0046
	bcc     L007B
	inx
L007B:	sta     ptr1
	stx     ptr1+1
	tya
	sta     (ptr1),y
;
; digits->segments[i+1] += 1;
;
	tax
	lda     L0046
	clc
	adc     #$01
	bcc     L007C
	inx
	clc
L007C:	adc     (sp),y
	sta     ptr1
	txa
	iny
	adc     (sp),y
	sta     ptr1+1
	dey
	lda     (ptr1),y
	clc
	adc     #$01
	sta     (ptr1),y
;
; for (i = 0; i < 6; ++i)
;
L007E:	inc     L0046
	jmp     L007D
;
; if (digits->segments[7] > 9)
;
L0049:	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$07
	lda     (ptr1),y
	cmp     #$0A
	bcc     L005A
;
; digits->segments[7] = 9;
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     #$09
	ldy     #$07
	sta     (ptr1),y
;
; }
;
L005A:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ __fastcall__ digit_increment (__near__ struct digits *, signed char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_digit_increment: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; digits->segments[0] += amt;
;
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     pushax
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sta     ptr1
	ldy     #$02
	lda     (sp),y
	clc
	adc     ptr1
	ldy     #$00
	jsr     staspidx
;
; digit_update(digits);
;
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _digit_update
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ __fastcall__ nt_print (unsigned int, __near__ const unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nt_print: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; vram_adr(adr);
;
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _vram_adr
;
; if (!(*str)) break;
;
L006A:	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1),y
	beq     L006B
;
; vram_put((*str++)+ASCII_OFFSET);
;
	iny
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     regsave
	stx     regsave+1
	clc
	adc     #$01
	bcc     L0074
	inx
L0074:	jsr     stax0sp
	ldy     #$00
	lda     (regsave),y
	sec
	sbc     #$20
	jsr     _vram_put
;
; while(1)
;
	jmp     L006A
;
; }
;
L006B:	jmp     incsp4

.endproc

